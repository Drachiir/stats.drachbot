{% extends 'base.html' %}

{% block content %}
<style>
    :root{
        --textsize: clamp(0.6rem, 1vw, 1.2rem);
        --waveimgsize: clamp(32px, 5vw, 48px);
        --imgsize: clamp(20px, 3vw, 28px);
    }
    r {
      font-family: "Roboto", sans-serif;
      font-weight: 300;
      font-style: normal;
    }
    r2 {
        font-family: "Roboto", sans-serif;
        font-weight: 300;
        font-style: normal;
        vertical-align: middle;
        font-size: 1rem;
    }
    r3 {
        font-family: "Roboto", monospace;
        font-weight: 300;
        font-style: normal;
        font-size: 0.85rem;
    }
    .profile-div {
        min-width: max-content;
        min-height: max-content;
        white-space: nowrap; /* Prevents text from wrapping inside the div */
        margin: 8px;
    }
    #chart-container {
        width: 100%; /* Ensure it takes full width */
        height: 400px; /* You can adjust the height */
        display: flex;
        justify-content: center;
        align-items: center;
    }

    /* Make sure the canvas stretches within the container */
    canvas {
        width: 100% !important;
        height: 100% !important;
    }
    .profile-main {
        background: #171717;
        border-radius: 10px;
    }
    @media (max-width: 480px) {
        .profile-main {
            max-width: 100%;
        }
    }
    @media (max-width: 768px) {
        .profile-main{
            max-width: 100%;
        }
    }
    table th{
        opacity: .85;
        background-color: #222223 !important;
    }
    table td{
        background-color: rgba(0, 0, 0, 0) !important;
    }
    .player-row:hover{
        cursor: pointer;
    }
    i[data-title]:hover::after, i[data-title]:active::after{
        content: attr(data-title);
        background-color: black;
        font-family: "Roboto", sans-serif;
        text-align: center;
        border-radius: 10px;
        padding: 5px;
        border: gray 1px solid;
        position: absolute;
        z-index: 1;
    }
    /* Apply custom styles to scrollable div */
    .scrollable {
        height: 170px;   /* Adjust the height as needed */
        overflow-y: auto; /* Enable vertical scrolling */
        width: 100%;
    }
    /* Custom scrollbar styles for WebKit browsers (Chrome, Safari, etc.) */
    .scrollable::-webkit-scrollbar {
        width: 12px; /* Width of the scrollbar */
    }
    /* Track - the background of the scrollbar */
    .scrollable::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0); /* Light gray background */
    }
    /* Handle - the draggable part of the scrollbar */
    .scrollable::-webkit-scrollbar-thumb {
        background: #3a99ff; /* Darker gray handle */
        border-radius: 10px; /* Round edges */
    }
    /* Handle on hover */
    .scrollable::-webkit-scrollbar-thumb:hover {
        background: #31afdd; /* Darker on hover */
    }
    .strokeText{
        -webkit-text-stroke: 3px black;
        paint-order: stroke fill;
        font-weight: 400;
    }
</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<div class="container-lg" style="padding-top: 2vw; display: block">
    <div class="profile-main" style="position: relative">
        <div style="padding: 10px; display: flex; flex-wrap: wrap; overflow: hidden; align-items: flex-start; justify-content: space-evenly">
            <div style="text-align: center; width: 250px; overflow: hidden">
                <img style="vertical-align: middle; clip-path: circle();" src="https://cdn.legiontd2.com/{{ api_profile["avatarUrl"] }}">
                <r2 style="font-size: 1.5rem"><b>{{ api_profile["playerName"] }}</b></r2>
                <r2 style="color: gold;"><b> {{ api_profile["guildTag"] }}</b></r2><br><br>
                <button class="btn btn-secondary" onclick="refreshPage()">Refresh</button>
                <button class="btn btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                  <r><b>Stats Pages</b></r>
                </button>
                <ul class="dropdown-menu bg-black">
                    {% for stat in stats_list %}
                        <li class="dropdown-item">
                            <a style="color: white; text-decoration: none;" href="/profile/{{ playername }}/{{ stat }}">
                            <img width="32" height="auto" style="vertical-align: middle" src="{{ image_list[loop.index0]}}">
                            <r2>{{ stat.capitalize() }}</r2><br></a>
                        </li>
                    {% endfor %}
                </ul>
            </div>
            <div class="profile-div">
                <r2 style=""><b>Season 2024 Stats</b></r2><br>
                <r2>{{ api_stats["rankedWinsThisSeason"] }}W - {{ api_stats["rankedLossesThisSeason"] }}L<br>({{ winrate([api_stats["rankedWinsThisSeason"],
                (api_stats["rankedWinsThisSeason"]+api_stats["rankedLossesThisSeason"])]) }} WR%)</r2><br>
                <img width="32" height="auto" style="vertical-align: middle" src="{{ get_rank_url(api_stats["overallElo"]) }}">
                <r2>{{ api_stats["overallElo"] }} </r2><r2 style="color: #919191">Current</r2><br>
                <img width="32" height="auto" style="vertical-align: middle" src="{{ get_rank_url(api_stats["overallPeakEloThisSeason"]) }}">
                <r2>{{ api_stats["overallPeakEloThisSeason"] }} </r2><r2 style="color: #919191">Peak</r2>
            </div>
            <div class="profile-div">
                <r2><b>Last {{ history|length }} Games </b></r2><i data-title="Latest 2 Patches ({{ patch }})" style="font-size:14px; color: #00c4ff" class="fa">?</i><br>
                <r2>{{ winlose[0] }}W - {{ winlose[1] }}L<br>({{ winrate([winlose[0], (winlose[0]+winlose[1])]) }} WR%)</r2><br>
                <r2>Elo: {{ elochange }}</r2>
            </div>
            {% for x in ["Teammates", "Enemies"] %}
                <div class="profile-div">
                    <table class="table table-sm table-hover scrollable" style="display: inline-block; max-height: 140px; overflow: hidden; overflow-y: scroll; border-collapse: separate; text-align: center">
                        <tbody>
                        <tr><th><r3>{{ x }}</r3></th><th><r3>Games</r3></th><th><r3>Winrate</r3></th><th><r3>Elo</r3></th></tr>
                            {% for mate in player_dict[x] %}
                                {% set mate_dict = player_dict[x][mate] %}
                                 <tr class="player-row" data-href="/profile/{{ mate_dict["Playername"] }}">
                                     <td style="text-align: left;"><r3>{{ mate_dict["Playername"][:14] }}</r3></td>
                                     <td><r3>{{ mate_dict["Count"] }}</r3></td>
                                     <td><r3>{{ custom_winrate([mate_dict["Wins"],mate_dict["Count"]]) }}%</r3></td>
                                     <td><r3>{{ plus_prefix(mate_dict["EloChange"]) }}</r3></td>
                                 </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            {% endfor %}
            <div style="display: flex; flex-wrap: wrap; justify-content: space-evenly; width: 100%">
                <div class="profile-div">
                    <r2>Wave 1 Tendency:</r2><br>
                    <img width="36" height="auto" src="https://cdn.legiontd2.com/icons/UpgradeKingAttack.png"><r2 class="strokeText">{{ wave1[0] }}%</r2>
                    <img width="36" height="auto" src="https://cdn.legiontd2.com/icons/Snail.png"><r2 class="strokeText">{{ wave1[1] }}%</r2>
                    <img width="36" height="auto" src="https://cdn.legiontd2.com/icons/Mythium32.png"><r2 class="strokeText">{{ wave1[2] }}%</r2>
                </div>
                {% for fav_category in [["Favorite Openers", "Opener", openers, "openstats"],
                                        ["Favorite Masterminds", "MMs", mms, "mmstats"],
                                        ["Favorite Legion Spells", "Spell", spells, "spellstats"]] %}
                    <div class="profile-div">
                        <r2>{{ fav_category[0] }}:</r2><br>
                        <div style="display: flex">
                        {% for key in fav_category[2] %}
                            <div style="position: relative;">
                                <a style="color: white; text-decoration: none" href="/profile/{{ playername }}/{{ fav_category[3] }}/{{ patch }}/{{ elo }}/{{ key|lower }}">
                                    <img width="36" height="auto" src="{{ get_cdn(key, fav_category[1]) }}">
                                    <r2 class="strokeText" style="position: absolute; bottom: -4px; left: 0;">{{ ((fav_category[2][key] / games * 100)|round|string).strip('.0') }}%</r2>
                                </a>
                            </div>
                        {% endfor %}
                        </div>
                    </div>
                {% endfor %}
            </div>
            <div id="chart-container" style="position: relative;">
                <div class="input-group" style="position: absolute; right: 10px; top: 20px; z-index: 10; width: 150px">
                    <input type="number" id="dataLimit" class="form-control form-control-sm" style="width: 80px;" min="1" value="100">
                    <button class="btn btn-secondary btn-sm" onclick="updateChart()">Apply</button>
                </div>

                <!-- Chart -->
                <canvas id="myChart"></canvas>
            </div>
        </div>
    </div>
    <div style="max-height: 95vh; overflow-y: scroll; border-radius: 10px; padding-top: 5px">
        <div style="text-align: center"><r2 style="font-size: 1.5rem">Ranked Match History</r2></div>
    {% for game in history[:short_history] %}
        <div style="background: #171717; border-radius: 10px; display: flex; padding: 10px">
            <div style="display: flex; gap: 5px; text-wrap: nowrap; width: 100%; justify-content: center">
                <div style="padding-left: 10px; width: 40%">
                    <a style="color: white; text-decoration: none;"  href="{{ game["gamelink"] }}">
                        <div>
                            <img style="vertical-align: middle; clip-path: circle(); width: var(--waveimgsize)" src="{{ game["EndWave"] }}">
                            {% if game["Result_String"][0] %}
                                <r2 style="color: #6af945; font-size: var(--textsize)">{{ game["Result_String"][1] }} ({{ game["EloChange"] }} Elo)</r2>
                            {% else %}
                                <r2 style="color: #d64444; font-size: var(--textsize)">{{ game["Result_String"][1] }} ({{ game["EloChange"] }} Elo)</r2>
                            {% endif %}
                        </div>
                    </a>
                    <div style="display: flex; gap: 5px; overflow: hidden">
                        <div style="position: relative;">
                            <img style="vertical-align: middle; clip-path: circle(); width: var(--imgsize); height: auto" src="{{ get_cdn(game["Mastermind"], "MMs") }}">
                            {% if game["Megamind"] %}
                                <img loading="lazy" style="top:0;left: 0; position: absolute; clip-path: circle(); width: calc(var(--imgsize) / 2)" src="https://cdn.legiontd2.com/icons/Items/Megamind.png">
                            {% endif %}
                        </div>
                        <div>
                            <img style="vertical-align: middle; clip-path: circle(); width: var(--imgsize); height: auto" src="https://cdn.legiontd2.com/Icons/Worker.png">
                            <r style="font-size: var(--textsize)">{{ game["Worker"] }}</r>
                        </div>
                        <div>
                            <img style="vertical-align: middle; clip-path: circle(); width: var(--imgsize); height: auto" src="{{ get_cdn(game["Spell"], "Spell") }}">
                        </div>
                        {% for opener_unit in game["Opener"].split(",")|reverse %}
                            <img style="vertical-align: middle; clip-path: circle(); width: var(--imgsize); height: auto" src="{{ get_cdn(opener_unit, "Unit") }}">
                        {% endfor %}
                    </div>
                </div>
                <div style="display: flex; white-space: nowrap; gap: 20px; align-items: center; width: 40%">
                    {% for x in [game["players_data"][:2], game["players_data"][2:]] %}
                        <div style="width: 50%">
                            {% for player in x %}
                                {% if player[0] == api_profile["playerName"] %}
                                    {% set color = "#34a9db" %}
                                {% else %}
                                    {% set color = "white" %}
                                {% endif %}
                                <a style="color: white; text-decoration: none; padding: 5px"  href="/profile/{{ player[0] }}">
                                    <img style="width: 16px;" src="{{ get_rank_url(player[1]) }}">
                                    <r2 style="font-size: var(--textsize); color: {{ color }}">{{ player[0] }}</r2>
                                </a><br>
                            {% endfor %}
                        </div>
                    {% endfor %}
                </div>
                <div style="width: 20%; position: relative;">
                    <div style="position: absolute; top: -15%; right: 0">
                        <a style="color: white; text-decoration: none;"  href="{{ game["gamelink"] }}">
                            <div>
                                <r2 style="color: #a5a5a5; font-size: var(--textsize)">{{ game["time_ago"] }}</r2><r2>🔗</r2>
                            </div>
                        </a>
                    </div>
                </div>
            </div>
        </div><br>
    {% endfor %}
    </div>
</div>
<script>
    // Get the labels and values from Flask (Jinja2 templating)
    const labels = {{ labels|tojson }};
    const values = {{ values|tojson }};
    const dataLength = labels.length;

    // Preload images in a more robust way
    const rankImagesCache = {};

    function preloadRankImages(callback) {
        const rankThresholds = [
            { rank: 2800, url: 'https://cdn.legiontd2.com/icons/Ranks/Simple/Legend.png' },
            { rank: 2600, url: 'https://cdn.legiontd2.com/icons/Ranks/Simple/GrandMaster.png' },
            { rank: 2400, url: 'https://cdn.legiontd2.com/icons/Ranks/Simple/SeniorMaster.png' },
            { rank: 2200, url: 'https://cdn.legiontd2.com/icons/Ranks/Simple/Master.png' },
            { rank: 2000, url: 'https://cdn.legiontd2.com/icons/Ranks/Simple/Expert.png' },
            { rank: 1800, url: 'https://cdn.legiontd2.com/icons/Ranks/Simple/Diamond.png' },
            { rank: 1600, url: 'https://cdn.legiontd2.com/icons/Ranks/Simple/Platinum.png' },
            { rank: 1400, url: 'https://cdn.legiontd2.com/icons/Ranks/Simple/Gold.png' },
            { rank: 1200, url: 'https://cdn.legiontd2.com/icons/Ranks/Simple/Silver.png' },
            { rank: 1000, url: 'https://cdn.legiontd2.com/icons/Ranks/Simple/Bronze.png' }
        ];

        let loadedImagesCount = 0;
        const totalImages = rankThresholds.length;

        rankThresholds.forEach(rankObj => {
            const img = new Image();
            img.src = rankObj.url;
            img.onload = function() {
                rankImagesCache[rankObj.rank] = img;
                loadedImagesCount++;
                // Once all images are preloaded, call the callback
                if (loadedImagesCount === totalImages) {
                    callback();
                }
            };
            img.onerror = function() {
                console.error('Failed to load image:', rankObj.url);
            };
        });
    }

    // Function to get rank image based on Elo value
    function getRankImageForValue(value) {
        if (value >= 2800) return rankImagesCache[2800];
        if (value >= 2600) return rankImagesCache[2600];
        if (value >= 2400) return rankImagesCache[2400];
        if (value >= 2200) return rankImagesCache[2200];
        if (value >= 2000) return rankImagesCache[2000];
        if (value >= 1800) return rankImagesCache[1800];
        if (value >= 1600) return rankImagesCache[1600];
        if (value >= 1400) return rankImagesCache[1400];
        if (value >= 1200) return rankImagesCache[1200];
        return rankImagesCache[1000];
    }

    // Custom plugin to draw icons on the chart at threshold changes
    const customPlugin = {
        id: 'customPlugin',
        afterDatasetDraw(chart) {
            const ctx = chart.ctx;
            const meta = chart.getDatasetMeta(0);
            const dataPoints = meta.data;
            const rankImages = [];
            const count = dataPoints.length;

            // Always show the first, middle, and last data point
            const indicesToShow = [0, Math.floor(count / 2), count - 1];

            indicesToShow.forEach(index => {
                const dataPoint = dataPoints[index];
                const value = chart.data.datasets[0].data[index];
                const rankImage = getRankImageForValue(value);
                if (rankImage) {
                    rankImages.push({ x: dataPoint.x, y: dataPoint.y, img: rankImage });
                }
            });

            // Draw rank icons at specified points
            rankImages.forEach(({ x, y, img }) => {
                ctx.drawImage(img, x - 12, y - 12, 24, 24);  // Adjust size and position of the icon
            });
        }
    };

    // Custom Y-axis tick callback to replace text with placeholders for icons
    function yTickCallback(value) {
        return value;  // No additional spaces, keep the value as it is
    }

    // Function to replace tick labels with icons
    function replaceTickImages(chart) {
        const yScale = chart.scales.y;

        // Get the tick values and positions
        const ticks = yScale.ticks;

        ticks.forEach((tick, index) => {
            const value = tick.value;
            const img = getRankImageForValue(value);
            if (img) {
                const tickX = yScale.left - 30; // Adjust position to put image to the left of the tick label
                const tickY = yScale.getPixelForTick(index) - 12; // Calculate the pixel position for the tick
                chart.ctx.drawImage(img, tickX, tickY, 24, 24);  // Draw the image
            }
        });
    }

    // Custom plugin to handle Y-axis icons after drawing
    const tickIconPlugin = {
        id: 'tickIconPlugin',
        afterDraw(chart) {
            replaceTickImages(chart);  // Replace tick labels with images after the chart is drawn
        }
    };

    // Declare myChart globally so it can be accessed inside updateChart
    let myChart;

    // Initialize chart after images are preloaded
    preloadRankImages(function() {
        const ctx = document.getElementById('myChart').getContext('2d');
        myChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Elo',
                    data: values,
                    backgroundColor: 'rgba(67,144,255,0.91)',
                    borderColor: 'rgb(79,189,237)', // Initial color
                    borderWidth: 1,
                    pointRadius: 0  // Remove dots
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        ticks: {
                            maxTicksLimit: 20,
                            font: {
                                size: 12
                            }
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.2)',
                            borderColor: 'rgba(255, 255, 255, 0.5)',
                            borderWidth: 1
                        }
                    },
                    y: {
                        beginAtZero: false,
                        ticks: {
                            font: {
                                size: 12
                            },
                            callback: yTickCallback  // Use custom tick callback for labels
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.2)',
                            borderColor: 'rgba(255, 255, 255, 0.5)',
                            borderWidth: 1
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: `Last ${labels.length} Ranked Games`,
                        color: 'rgb(204,204,204)',
                        font: {
                            size: 14
                        },
                        padding: {
                            top: 10,
                            bottom: 10
                        }
                    },
                    tooltip: {
                        enabled: true,
                        mode: 'nearest',
                        intersect: false
                    }
                },
                layout: {
                    padding: {
                        top: 5,
                        bottom: 20
                    }
                }
            },
            plugins: [customPlugin, tickIconPlugin]  // Use both custom plugins
        });
    });

    // Function to update chart based on user input
    function updateChart() {
        let limit = parseInt(document.getElementById('dataLimit').value, 10);

        // Adjust limit if it exceeds available data length
        if (limit > dataLength) {
            limit = dataLength;
            document.getElementById('dataLimit').value = limit;
        }

        if (limit > 0) {
            const limitedLabels = labels.slice(-limit);
            const limitedValues = values.slice(-limit);

            // Update chart data
            myChart.data.labels = limitedLabels;
            myChart.data.datasets[0].data = limitedValues;

            // Recalculate min and max values
            const minValue = Math.min(...limitedValues);
            const maxValue = Math.max(...limitedValues);
            myChart.options.scales.y.min = minValue - 10;
            myChart.options.scales.y.max = maxValue + 10;

            // Update chart title
            myChart.options.plugins.title.text = `Last ${limit} Ranked Games`;

            // Refresh the chart
            myChart.update();
        } else {
            alert("Please enter a valid number greater than 0.");
        }
    }

    // Initialize the input field with the maximum value based on the data length
    document.getElementById('dataLimit').setAttribute('max', dataLength);
    document.getElementById('dataLimit').value = Math.min(100, dataLength); // Default to 100 or max available data
</script>




{% endblock %}